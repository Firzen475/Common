# Железо
3) kvm IPMI что это и в чём разница.
4) Этапы загрузки ОС
5) BIOS, UEFI, PXE
2) Информация о железе в Linux (директория и утилиты)
# OC
## Всё о загрузке linux
   1) Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.
   2) Что такое уровни выполнения (run levels) в Linux
   3) Какие основные части компоненты включает в себя система на базе дистрибутива linux?
   4) Что такое BIOS, UEFI? Основы и различия
   5) Что такое PXE? Как загрузиться по сети?
   6) Что такое ядро, initramfs, загрузчик?
   7) Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах?
   8) Что такое systemd и init ? В чем основное преимущество первого над вторым?
   9) Как понять используется ли в системе systemd?
   10) Какие алгоритмы планирования ресурсов в linux ты знаешь  

## Ответ:

1) После запуска ПК загружается (из ПЗУ на материнской плате) низкоуровневое ПО BIOS или UEFI.  

BIOS (Basic Input/Output System):
  - режим 16 бит
  - поддерживает MBR-размета (максимум 2 ТБ)
  - последовательная инициализация
  - передаёт управление первым секторам диска (MBR раздел)
UEFI (Unified Extensible Firmware Interface):
  - режим 32\64 бита
  - поддержка GPT-разметка (> 2 ТБ)
  - параллельная инициализация
  - ищет и запускает исполняемые файлы .efi в FAT разделе ESP (EFI System Partition)
----
### 2) PXE или GRUB  

PXE (Preboot eXecution Environment):
 - Клиент хранится в прошивке сетевой карты или UEFI
 - Делает широковещательный запрос и получает от DHCP (Dynamic Host Configuration Protocol) адрес TFTP (Trivial File Transfer Protocol) 
 - Скачивает с сервера и загрузчик (pxelinux.0/grubx64.efi) и grub.cfg.
 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs)).
 - В параметрах ядра указывается расположение iso и cloud-init.
 - Загрузка ядра в память и передача управления.

GRUB (GRand Unified Bootloader):
  - (MBR) Stage 1 ищет Stage 2 на диске
  - (GPT) Stage 1 запуск исполняемого .efi
  - Stage 2 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs))
  - Загрузка ядра в память и передача управления.

-----
### 3) Инициализация  

#### Общее:
- Этап initrd:
  - Ядро монтирует минимальную виртуальную файловую систему в оперативку из initramfs.
  - В ней содержатся утилиты и драйвера для подготовки оборудования.
  - Монтирование корневой файловой системы (параметр ядра root=/dev/sda1)
  - Переключается на rootfs.
  - Запуск PID 1 (/sbin/init)

- Список runlevel:
  - 0 - Выключение
  - 1 - Одно пользовательский режим
  - 2 - Многопользовательский без сети.
  - 3 - Многопользовательский с сетью (режим сервера)
  - 4 - Не используется
  - 5 - Графический режим
  - 6 - Перезагрузка

#### SysV init:  
- Конфиги сервисов (unit): `/etc/init.d/` (sh скрипты)
- Метод старта сервисов (target): 
  - Символические ссылки на скрипты, соответствующие runlevel. (`/etc/rc.d/rc[runlevel].d/`)
- Управление:
  - `runlevel [N]` - текущий runlevel  переключение.
  - `service`,`service <service>` - информация о сервисах.
  - `/etc/init.d/<service> [start|stop|restart|reload|status] <job>` - управление сервисами.
- Логи: Средствами сервисов.

#### Upstart (Ubuntu до ubuntu 14.10):  
- Конфиги сервисов (unit): `/etc/init/`
  - Типы:
    - `task` - Единоразовый вызов
    - `service` - Отслеживание состояния
  - Возможности:
    - Управление порядком запуска.
    - `initctl emit my-custom-event` - Собственные события в сервисах
    - `respawn` - Автоматический перезапуск
- Метод старта сервисов (target): 
  - Генерация событий при изменениях в системе:
    - Файловые системы смонтированы -> filesystem
    - Устройства обнаружены -> udev
    - Сетевые интерфейсы подняты -> networking
    - Сервис запущен\остановлен -> started \<service> \ stopped \<service>
    - Система перешла в определённый уровень работы -> runlevel [N]
- Управление:
  - `initctl list`,`initctl status <service>` - информация о сервисах.
  - `initctl [start|stop|restart|reload] <service>` - управление сервисами.
- Логи (при добавлении в конфиги `console log`):
  - `tail -f /var/log/upstart/<service>.log`

#### <span style="color: red;">Systemd:</span>
- Конфиги сервисов (unit): `/etc/systemd/system/`, `~/.config/systemd/user/`
  - Типы:
    * `.target` - узел загружен когда загружены все его зависимости.
    * `.service` - демоны.
    * `.timer` - задачи по расписанию.
    * `.socket` - отложенный запуск при обращении к сокету.
    * `.path` - отложенный запуск при изменении файлов в директории.
    * `.mount\.automount` - Монтирование (по запросу).
    * `.swap` - Управление swap-разделами.
    * `.slice` - Группировка процессов для cgroup.
  - Возможности:
    - Доделать позже
- Метод старта сервисов (target):
  * initrd.target - юниты initramfs.
  * sysinit.target - базовая инициализация (fs,net)
    * basic.target - минимальная готовая система
      * multi-user.target - пользовательские демоны
        * default.target - главная точка входа.
- Управление:
  - `systemctl daemon-reload` - перечитать сервисы.
  - `systemctl list-units`,`systemctl status <service>` - информация о сервисах.
  - `systemctl [enable|disable|start|stop|restart|reload] <service>` - управление сервисами.
  - `systemctl [reboot|poweroff|suspend|hibernate]` - Управление системой.
- Логи
  - `journalctl -u <service>` - Логи службы
  - `journalctl -f` - Режим слежения
  - `journalctl -b` - Логи текущей загрузки
----
### 4) Компоненты дистрибутива linux
  - Bootloader
  - Ядро - управляет инициализацией и взаимодействием с железом.
  - Системные библиотеки
  - Системные утилиты:
    - [Работа с файлами и директориями](#системные-утилиты)
  - Менеджер пакетов:
    - apt
    - pkg
    - yum
  - Службы и демоны:
    - systemd
    - sshd
    - cron
    - firewalld\iptables
    - apparmor
  - [Оболочка](#оболочки):
  - Графическая подсистема
----
## Ресурсы и мониторинг (CPU, RAM)
  1) Как посмотреть нагрузку на диски?
  2) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?
  3) Представлен вывод команды top. Что означает каждая запись в выводе?
  4) Что такое swap файл (подкачки)? Зачем он нужен, и как он работает? Какие данные в него записываются?
  5) Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?
  6) Что такое физическая память?
  7) Что такое виртуальная память?
  8) Почему в htop может быть не до конца корректная сводка по потребляемой памяти
  9) Где в системе можно посмотреть сводку по текущему потреблению памяти?
  10) Как работает оом киллер и для чего нужен? Out of memory, oom


## Файловые системы и их организация
  1) 
  2) 

3) Bash и его утилиты
   3) В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?
   4) Что значит $@, $!, $?, $$ в bash?
   5) Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?
   6) При перенаправлении команд (command1 | command2 ) перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?
   7) В чем разница между одинарными кавычками (') и двойными кавычками (")?
   8) a=5; true | { true && a=10; } чему будет равно a?

## Ответ:
  ОС на базе Linux имеют оболочки (терминал для исполнения команд) и набор встроенных утилит.  
#### Оболочки:
  - bash
  - ash
  - zsh
  - sh  
#### Принцип работы
  * Каждая сессия терминала это процесс. При выполнении команды выполняется POSIX команда `fork()`  
  * `fork()` создаёт копию процесса (память, переменные) и вызывает `execve()` для запуска утилиты  
  * Родитель ожидает получения `SIGCHILD` и результата выполнения в виде `stdout stderr` (файловые дескрипторы 1 и 2)
  * Дочерний процесс **видит** переменные родительского.  
  * Можно выстраивать цепочки команд (`pipe`) `command1 2>&1 | command2`  
  * _рассказать про кавычки_
#### Параметры и системные переменные
POSIX-special parameters:
  * `$0` — имя скрипта или shell.
  * `$1…$N` — позиционные параметры.
  * `$#` — количество аргументов.
  * `$@` — аргументы как отдельные слова.
  * `$*` — аргументы как одно слово.
  * `$?` — код возврата последней команды.
  * `$!` — PID последнего фонового процесса.
  * `$$` — PID текущего shell.
bash-special parameters:
  * `$BASH` — путь к бинарнику bash.
  * `$PPID` — PID родителя.
  * `$PWD` — текущий каталог.
Перенаправления:
  * `> file` — перезаписать stdout.
  * `>> file` — дописать stdout.
  * `2> file` — stderr → файл.
  * `2>&1` — stderr → stdout.
  * `&> file` — stdout + stderr → файл (bash).
  * `<<< "строка"` — here-string.
  * `<<EOF … EOF` — here-document.
  * `>|& file` — оба потока в файл (bash).
#### Системные утилиты:
(**_сказать не менее одного ключа_**)
  1. Работа с файлами и каталогами 
     - `ls <source>` — вывод содержимого каталога
       - `-a` - показать скрытые
       - `-l` - формат `<права> <количество hardlink> <user> <group>  <Размер> <Дата> file.txt`
       - `-i` - добавляет inode
     - `ln [-s]` - создать Hardlink\Symlink
     - `cp -R <source> <dest>` — копирование файлов/каталогов
     - `mv -R <source> <dest>` — перемещение/переименование
     - `rm -fr <source>` — удаление файлов/каталогов
     - `mkdir -p` / `rmdir -f` — создание и удаление каталогов
     - `stat` / `file` — информация о файлах
     - `find` — поиск файлов
       - `-name <pattern>` - шаблон
       - `-type [f|d|l]` — тип файла
       - `-size` — размер
       - `-[a|m|c]time [+|-]N` — время 
       - `-exec команда {} \;` — применить команду ко всем найденным.
     2. Просмотр и обработка содержимого файлов
     - `cat` — вывод содержимого
     - `head`, `tail` — первые/последние строки
     - `grep <pattern>` — поиск по содержимому
     - `wc` — подсчёт строк, слов, символов
     - `cut`, `sort`, `uniq`, `tr` — базовая обработка текстовых данных
     6. Архивация и сжатие
     - `tar`, `gzip`, `bzip2`, `zip`, `unzip` — работа с архивами
     7. Информационные утилиты
     - `df` — свободное место на дисках
     - `du` — размер файлов/каталогов
     - `uptime` — время работы системы
     - `dmesg` — сообщения ядра
     - `uname` — информация о системе

3)




4. Сетевые утилиты
- `ping` — проверка доступности узла
- `ifconfig` / `ip` — настройка сети
- `netstat` / `ss` — состояние соединений
- `wget`, `curl` — загрузка данных
- `scp`, `ssh` — удалённый доступ и передача файлов

5. Управление пользователями и правами
- `who`, `w`, `id` — информация о пользователях
- `passwd` — смена пароля
- `chmod`, `chown`, `chgrp` — управление правами доступа
- `su`, `sudo` — выполнение команд от имени другого пользователя
3. Управление процессами
- `ps` — список процессов
- `top` / `htop` — мониторинг процессов в реальном времени
- `kill`, `pkill`, `killall` — завершение процессов
- `nice` / `renice` — изменение приоритета процессов
1) OS level и компоненты
2) init, текущий init
3) PID
4) Что такое userspace, kernelspace? Чем они отличаются?
2) POSIX
3) SIG kill
3) Что такое системные вызовы?
4) process (статусы;proc/PID/;)
5) Как процессы в системе взаимодействуют между собой?
3) process vs thread
1) 
2) 
2) Что такое процесс? Что такое тред?
8) Какие алгоритмы планирования ресурсов в linux
1) top
2) LA CPU pinning
3) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности.
2) Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
3) RAM: структура; swap; утилиты; оом киллер
3) Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?
4) Что такое разделяемая память?
3) HDD: WA, блочные/символьные, 
4) Что такое major and minor numbers блочных устройств, чему они соответствуют?
5) Файловые системы, vfs, RAID, lvm, loop devices
6) 
6) inode - что это и где находятся физически.
7) hardlinks vs symlinks; как создать?
7) Где хранится информация об именах файлов, директорий?
6) Как создать файловую систему на блочном устройстве?
7) Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?
7) Каким образом осуществляется монтирование ФС?
8) Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?
2) Как определить, на каком физическом жёстком диске находится раздел с файловой системой?
3) Как узнать, какими процессами используется раздел?
4) При создании нового файла система возвращает ошибку no space left device
5) При создании нового файла пользователем система возвращает ошибку no space left on device
6) Приложение пишет в логи too many opened files.
7) df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)

1) Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли?
2) Как работает система разграничения доступа к файлам в linux? Какие возможности она предоставляет?
3) Основы bash ($,export,stdout,sudo,кавычки); a=5; true | { true && a=10; } чему будет равно a?
4) Файловые дескрипторы.
5) Как узнать что и куда пишет процесс (fd,stdout).
6) Как заставить приложение перестать писать в файл, не завершая процесс?
6) В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?
6) Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?
7) Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?
8) Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)
9) База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?







# Сеть


Статусы сетевого интерфейса.


Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?