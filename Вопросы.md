# Железо
3) kvm IPMI что это и в чём разница.
4) Этапы загрузки ОС
5) BIOS, UEFI, PXE
2) Информация о железе в Linux (директория и утилиты)
# OC
## Всё о загрузке linux
   1) Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.
   2) Что такое уровни выполнения (run levels) в Linux
   3) Какие основные части компоненты включает в себя система на базе дистрибутива linux?
   4) Что такое BIOS, UEFI? Основы и различия
   5) Что такое PXE? Как загрузиться по сети?
   6) Что такое ядро, initramfs, загрузчик?
   7) Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах?
   8) Что такое systemd и init ? В чем основное преимущество первого над вторым?
   9) Как понять используется ли в системе systemd?
   10) Какие алгоритмы планирования ресурсов в linux ты знаешь  

## Ответ:

1) После запуска ПК загружается (из ПЗУ на материнской плате) низкоуровневое ПО BIOS или UEFI.  

BIOS (Basic Input/Output System):
  - режим 16 бит
  - поддерживает MBR-размета (максимум 2 ТБ)
  - последовательная инициализация
  - передаёт управление первым секторам диска (MBR раздел)
UEFI (Unified Extensible Firmware Interface):
  - режим 32\64 бита
  - поддержка GPT-разметка (> 2 ТБ)
  - параллельная инициализация
  - ищет и запускает исполняемые файлы .efi в FAT разделе ESP (EFI System Partition)
----
### 2) PXE или GRUB  

PXE (Preboot eXecution Environment):
 - Клиент хранится в прошивке сетевой карты или UEFI
 - Делает широковещательный запрос и получает от DHCP (Dynamic Host Configuration Protocol) адрес TFTP (Trivial File Transfer Protocol) 
 - Скачивает с сервера и загрузчик (pxelinux.0/grubx64.efi) и grub.cfg.
 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs)).
 - В параметрах ядра указывается расположение iso и cloud-init.
 - Загрузка ядра в память и передача управления.

GRUB (GRand Unified Bootloader):
  - (MBR) Stage 1 ищет Stage 2 на диске
  - (GPT) Stage 1 запуск исполняемого .efi
  - Stage 2 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs))
  - Загрузка ядра в память и передача управления.

-----
### 3) Инициализация  

#### Общее:
- Этап initrd:
  - Ядро монтирует минимальную виртуальную файловую систему в оперативку из initramfs.
  - В ней содержатся утилиты и драйвера для подготовки оборудования.
  - Монтирование корневой файловой системы (параметр ядра root=/dev/sda1)
  - Переключается на rootfs.
  - Запуск PID 1 (/sbin/init)

- Список runlevel:
  - 0 - Выключение
  - 1 - Одно пользовательский режим
  - 2 - Многопользовательский без сети.
  - 3 - Многопользовательский с сетью (режим сервера)
  - 4 - Не используется
  - 5 - Графический режим
  - 6 - Перезагрузка

#### SysV init:  
- Конфиги сервисов (unit): `/etc/init.d/` (sh скрипты)
- Метод старта сервисов (target): 
  - Символические ссылки на скрипты, соответствующие runlevel. (`/etc/rc.d/rc[runlevel].d/`)
- Управление:
  - `runlevel [N]` - текущий runlevel  переключение.
  - `service`,`service <service>` - информация о сервисах.
  - `/etc/init.d/<service> [start|stop|restart|reload|status] <job>` - управление сервисами.
- Логи: Средствами сервисов.

#### Upstart (Ubuntu до ubuntu 14.10):  
- Конфиги сервисов (unit): `/etc/init/`
  - Типы:
    - `task` - Единоразовый вызов
    - `service` - Отслеживание состояния
  - Возможности:
    - Управление порядком запуска.
    - `initctl emit my-custom-event` - Собственные события в сервисах
    - `respawn` - Автоматический перезапуск
- Метод старта сервисов (target): 
  - Генерация событий при изменениях в системе:
    - Файловые системы смонтированы -> filesystem
    - Устройства обнаружены -> udev
    - Сетевые интерфейсы подняты -> networking
    - Сервис запущен\остановлен -> started \<service> \ stopped \<service>
    - Система перешла в определённый уровень работы -> runlevel [N]
- Управление:
  - `initctl list`,`initctl status <service>` - информация о сервисах.
  - `initctl [start|stop|restart|reload] <service>` - управление сервисами.
- Логи (при добавлении в конфиги `console log`):
  - `tail -f /var/log/upstart/<service>.log`

#### <span style="color: red;">Systemd:</span>
- Конфиги сервисов (unit): `/etc/systemd/system/`, `~/.config/systemd/user/`
  - Типы:
    * `.target` - узел загружен когда загружены все его зависимости.
    * `.service` - демоны.
    * `.timer` - задачи по расписанию.
    * `.socket` - отложенный запуск при обращении к сокету.
    * `.path` - отложенный запуск при изменении файлов в директории.
    * `.mount\.automount` - Монтирование (по запросу).
    * `.swap` - Управление swap-разделами.
    * `.slice` - Группировка процессов для cgroup.
  - Возможности:
    - Доделать позже
- Метод старта сервисов (target):
  * initrd.target - юниты initramfs.
  * sysinit.target - базовая инициализация (fs,net)
    * basic.target - минимальная готовая система
      * multi-user.target - пользовательские демоны
        * default.target - главная точка входа.
- Управление:
  - `systemctl daemon-reload` - перечитать сервисы.
  - `systemctl list-units`,`systemctl status <service>` - информация о сервисах.
  - `systemctl [enable|disable|start|stop|restart|reload] <service>` - управление сервисами.
  - `systemctl [reboot|poweroff|suspend|hibernate]` - Управление системой.
- Логи
  - `journalctl -u <service>` - Логи службы
  - `journalctl -f` - Режим слежения
  - `journalctl -b` - Логи текущей загрузки
----
### 4) Компоненты дистрибутива linux
  - Bootloader
  - Ядро - управляет инициализацией и взаимодействием с железом.
  - Системные библиотеки
  - Системные утилиты:
    - [Работа с файлами и директориями](#системные-утилиты)
  - Менеджер пакетов:
    - apt
    - pkg
    - yum
  - Службы и демоны:
    - systemd
    - sshd
    - cron
    - firewalld\iptables
    - apparmor
  - [Оболочка](#оболочки):
  - Графическая подсистема
----
## Процессы


#### Сигналы
SIGSEGV
SIGCHLD
SIGKILL
SIGINT
SIGSTOP
SIGCONT
SIGHUP
## Ресурсы и мониторинг (CPU, RAM)
  1) Как посмотреть нагрузку на диски?
  2) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?
  3) Представлен вывод команды top. Что означает каждая запись в выводе?
  4) Что такое swap файл (подкачки)? Зачем он нужен, и как он работает? Какие данные в него записываются?
  5) Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?
  6) Что такое физическая память?
  7) Что такое виртуальная память?
  8) Почему в htop может быть не до конца корректная сводка по потребляемой памяти
  9) Где в системе можно посмотреть сводку по текущему потреблению памяти?
  10) Как работает оом киллер и для чего нужен? Out of memory, oom
  11) Что такое iowait и почему он может появляться?
## Ответ:
#### CPU:
  * Можно посмотреть 3-мя показателями: Load average (LA); PSI some CPU; Колонка %CPU
    * `Load average` - Среднее количество процессов в очереди (состояние D(uninterruptible sleep)) за 1, 5, 15 мин
    * `PSI CPU` - Время, простоя из-за конкуренции
      * `some` - хотя бы один runnable-поток не получил ресурс. `(avg10 ≈ (1.5 / 10) * 100% = 15%)`
      * `full` - все потоки ожидают ресурс. 
    * `%CPU` - количество загруженных ядер одним процессом (100% = 1ядро)
  * Load average учитывает процессы, ожидающие iowait(взаимодействие с диском)
  * Измеряется в виртуальных ядрах (0.5 ядра = 50% = 0.5m)
### RAM:
  * Физическая память (ОЗУ) - установленная RAM, линейно адресуемая.
    * линейно адресуемая - ячейка имеет адрес и доступна и обращение напрямую
    * frame - Разбита на фреймы соответствующая размеру Page
  * Виртуальная память (ОЗУ+swap) - память, расширенная за счёт swap, с защитой и изоляцией процессов.
  * Виртуальный адрес - адрес страницы в виртуальной памяти, который транслируется в физическую по Page Table.
    * `malloc()` - резервирование адресного пространства.
    * `mmap()` - системный вызов создаёт адрес в виртуальной памяти и трансляцию в физическую. 
    * `[ PML4 index | PDPT index | PD index | PT index | offset ]` - виртуальный адрес или координаты в Page Table
  * `Page Table` - набор со зависимых таблиц, по которым читаются данные. Находятся всегда в физической памяти.
    * `PML4` - главная таблица с фиксированным адресом
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
    * `PDPT` - таблица содержит либо ссылки на таблицы PD, либо вся запись является большой страницей (1Gb)
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
      * `PS=1` - вся запись это страница
    * `PD` - таблица содержит либо ссылки на таблицы PT, либо вся запись является большой страницей (2МБ)
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
      * `PS=1` - вся запись это страница
    * `PT` - записи содержат страницы (4КБ)
      * `Page Entry` - если записи являются страницами, а не ссылками, то они имеют флаги `(PDPT,PD,PT)`
        * `Read/Write (RW) [0|1]`
        * `User/Supervisor (U/S)`
        * `Accessed` - страница была использована и можно её удалять
        * `Dirty` - страница изменена и требует сохранения в swap при вытеснении.
        * `NX (No Execute)` - флаг запрета на исполнение. Напрямую связан с chmod +x.
    * `CoW` - Новые страницы создаются при изменении (нужно раскрыть с примером).
### OOM Killer:
  * Механизм, который завершает процесс при нехватке памяти.
  * `oom_score` - стоимость процесса, наибольший завершается первым
    * объём потребляемой памяти
    * приоритет (oom_score_adj)
    * принадлежность к пользователю/системе
    * важность для работы ядра
  * Управление:
    * `/proc/<pid>/oom_score` — текущая оценка процесса. 
    * `/proc/<pid>/oom_score_adj` — ручная корректировка от -1000 до 1000.
  * Мониторинг:
    * dmesg или /var/log/kern.log
#### Управление
  * **cgroup** и управление ресурсами
    * Добавление
      * `/sys/fs/cgroup/<group name>/cgroup.procs`
      * `/sys/fs/cgroup/<group name>/cgroup.controllers`
    * Управление
      * `/sys/fs/cgroup/<group name>/cpu.[max|weight|stat]` - Управление и статистика по CPU.
      * `/sys/fs/cgroup/<group name>/memory.[max|high|min|low|stat]` - Управление и статистика по RAM.
      * `/sys/fs/cgroup/<group name>/io.[max|weight|stat]` - Управление и статистика по I/O.
      * `/sys/fs/cgroup/<group name>/pids.[max|current]` - Ограничение на процессы и статистика.
      * `/sys/fs/cgroup/<group name>/pressure/[cpu|memory|io].pressure` - PSI (Pressure Stall Information)
  * **swap** 
    * `swapon /swapfile` `swapoff /swapfile` - включение и отключение
    * `/proc/sys/vm/swappiness` - настройка агрессивности использования `swap` для всей системы

#### Мониторинг
  * `top\htop` - мониторинг CPU и RAM

|          |       |         |              |                              |          |                           |                           |                              |      |      |         |
|----------|-------|---------|--------------|------------------------------|----------|---------------------------|---------------------------|------------------------------|------|------|---------|
| top      | up    | users   | load average |
| Tasks:   | total | running | sleeping     | zombie                       |
| %Cpu(s): | us    | sy      | ni(nice)     | id(idle)(Простой процессора) | wa       | hi(аппаратные прерывания) | si(софтверные прерывания) | st («украдено» гипервизором) |
| Mem:     | total | free    | used         | buff/cache                   |
| Swap:    | total | free    | used         | avail                        |
| PID      | USER  | STATUS  | PRI          | NI                           | DISC R/W | VIRT                      | RES                       | SHR                          | MEM% | CPU% | COMMAND |

## Файловые системы и их организация
  1) Что такое блочные устройства? Какие элементарные операции можно с ними производить?
  2) Что такое символьные устройства? Какие элементарные операции с ними можно производить?
  3) Что такое major and minor numbers блочных устройств, чему они соответствуют?
  4) Что такое файловая система? Для чего она нужна?
  5) Как создать файловую систему на блочном устройстве? Какие параметры можно задать при создании?
  6) Что такое inodes айноды
  7) Где физически находятся inodes айноды
  8) По какой причине и на какого типа системах айноды могут закончиться? И к чему это может привести?
  9) Какая файловая система бывает динамическими айнодами и что это такое, зачем нужно?
  10) Где хранится информация об именах файлов, директорий?
  11) Каким образом осуществляется монтирование ФС? Как можно посмотреть список примонтированных ФС?
  12) Что такое псевдофайловая система?
  13) Какие проблемы могут возникать с файловой системой и жёстким диском? Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?
  14) Какую файловую систему выбрать ext4 или xfs?
  15) Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?
  16) Как узнать, какими процессами используется раздел?
  17) Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?
  18) Что такое RAID? Какие основные типы RAID существуют, чем они отличаются?
  19) Какие средства для работы с программными RAID массивами существуют в linux?
  20) Что такое LVM? Для решения каких задач он предназначен?
  21) Что такое loop devices? Как их можно использовать?
  22) При создании нового файла система возвращает ошибку no space left device
  23) df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)
  24) При создании нового файла пользователем система возвращает ошибку no space left on device
## Ответ:
### Физическая организация (RAID)
  * Символьные устройства
    * Клавиатура, мышь, последовательный порт.
    * Передача данных побайтно, медленные.
  * Блочные устройства
    * Любые устройства хранения, которые можно разбить на блоки. Доступ к блокам происходит независимо.
    * Сюда входят RAM-диски, компакт-диски, дискеты
    * Монтируются в `/dev/`
    * Посмотреть можно через `lsblk` `lspsi`
    * Управляются контроллерами через драйвера.
      * если выполнить `ls /dev/` - мажорные(драйвер) минорные(порядковый номер) номера - объяснить

  * `RAID 0` - Чередование
    * Описание
      * Требуется минимум 2 диска.
      * Все диски объединяются в общее пространство. Используется вся память.
    * Плюсы
      * Высокая скорость записи (кратно количеству) - можно писать параллельно на несколько дисков.
    * Минусы
      * Нет отказоустойчивости.
  * `RAID 1` - Зеркалирование
    * Описание
      * Требуется количество дисков кратное 2.
      * Данные записываются дважды на оба диска.
      * Скорость сопоставима с обычным диском.
    * Плюсы
      * При сбое данные копируются с зеркала. Идеальная отказоустойчивость
    * Минусы
      * Эффективная ёмкость равна половине от фактической.
  * `RAID 5` - Одинарная точность
    * Описание
      * Требуется 3-16 дисков
      * Расчёт и восстановление: `P = D1 XOR D2 XOR D3` -> `D1 = P XOR D2 XOR D3`
    * Плюсы
      * Выдерживает отказ 1
      * Эффективная ёмкость = (N – 1) × размер_диска
    * Минусы
      * Запись медленнее из-за расчёта чётности
      * Лавинный отказ при восстановлении
    * `RAID 6` - Двойная точность
      * Описание
        * Требуется минимум 4 диска
        * Расчёт `P = D1 XOR D2 XOR D3` `Q = a1*D1 ⊕ a2*D2 ⊕ a3*D3`
      * Плюсы
        * Выдерживает отказ 2
        * Эффективная ёмкость = (N – 2) × размер_диска
        * Высокая надёжность с малыми потерями ёмкости
        * Вероятность выхода из строя 2 дисков минимальна
      * Минусы
        * Скорость записи до 20% ниже из-за расчёта чётности
        * Долгое восстановление
    * `RAID 10`
      * Описание
        * Комбинация `RAID 1` и `RAID 0` - сначала зеркалируются, потом дублируются
      * Плюсы 
        * Все плюсы `RAID 1` и `RAID 0`
      * Минусы
        * Дорого
#### Управление
  * через контроллеры с собственным буфером (своя оперативная память и самостоятельный расчёт чётности)
    * Диски подключаются к контроллеру
    * Получившийся диск монтируется как обычный диск.
  * mdadm - программный рейд 
    * Объединяет разделы или диски в рейд и управляет логикой записи.
    * При инициализации на этапе init, можно использовать как root раздел
#### Мониторинг
  * `cat /proc/mdstat` - состояние рейда
  * `mdadm --detail /dev/md0` - информация о рейде
  * Логи сборки
    * `journalctl -k | grep md`
    * `dmesg | grep md`
  * Можно настроить уведомления на почту

### Физическая организация (Файловая система ext4)
```shell
(FS)
  ├── Superblock - находится в начале раздела и дублируется в блоках
     ├── (Полный размер, размер блока, размер группы блоков, количество групп)
     ├── Group Descriptor Table - ссылки на Block Group
        ├── GroupDesc[0] -> (BlockBitmap0, InodeBitmap0, InodeTable0)
        ├── GroupDesc[1] -> (BlockBitmap1, InodeBitmap1, InodeTable1)
        ├── GroupDesc[2] -> ...
     ├── Block Group N - группа блоков ([размер блока]*[размер группы блоков])
        ├── Superblock copy
        ├── Group descriptor copy
        ├── Block Bitmap - битовая карта блоков
        ├── Inode Bitmap - битовая карта inode
        ├── Inode Table [] - Таблица с метаданными о файле (inode)
            ├── Размер файла
            ├── Тип и права
            ├── UID / GID
            ├── Временные метки
                ├── ctime - создание
                ├── mtime - изменение
                ├── atime - доступ
                ├── crtime - время создания файла (если поддерживается)
            ├── Счётчик ссылок
            ├── Флаги
            ├── Extents [] - карты расположения данных
                ├── Extent 1: start=10, length=4
                    ├── Data Block 10
                    ├── Data Block 11
                    ├── Data Block 12
                    ├── Data Block 13
                ├── Extent 2: start=20, length=8
                    ├── Data Block 20
                    ├── ...
                    ├── Data Block 27
        ├── Directory Entries (если inode — каталог)
            ├── filename1 -> inode X
            ├── filename2 -> inode Y
        ├── Extended Attributes (xattr)
            ├── attr1
            ├── attr2
        ├── Data Block [] - фактические блоки на диске, на которые ссылается Extent 
            ├── Data Block 10...14 
            ├── Data Block 20...28

```

  * `Superblock` - Содержит метаинформацию о fs (Полный размер, размер блока, количество блоков\node), находится в начале раздела и дублируется в блоках. По этим данным можно найти '
    * `journal` - перед операцией записывает намерение, а после операции commit. Согласованность.
    * `Block Group`
      * поиск 
#### Управление
  * `mkfs -t ext4 /dev/sdb1` - создание файловой системы в разделе
    * 

## Bash и его утилиты
   1) В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?
   2) Что значит $@, $!, $?, $$ в bash?
   3) Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?
   4) При перенаправлении команд (command1 | command2 ) перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?
   5) В чем разница между одинарными кавычками (') и двойными кавычками (")?
   6) a=5; true | { true && a=10; } чему будет равно a?

## Ответ:
  ОС на базе Linux имеют оболочки (терминал для исполнения команд) и набор встроенных утилит.  
#### Оболочки:
  - bash
  - ash
  - zsh
  - sh  
#### Принцип работы
  * Каждая сессия терминала это процесс. При выполнении команды выполняется POSIX команда `fork()`  
  * `fork()` создаёт копию процесса (память, переменные) и вызывает `execve()` для запуска утилиты  
  * Родитель ожидает получения `SIGCHILD` и результата выполнения в виде `stdout stderr` (файловые дескрипторы 1 и 2)
  * Дочерний процесс **видит** переменные родительского.  
  * Можно выстраивать цепочки команд (`pipe`) `command1 2>&1 | command2`  
  * _рассказать про кавычки_
#### Параметры и системные переменные
POSIX-special parameters:
  * `$0` — имя скрипта или shell.
  * `$1…$N` — позиционные параметры.
  * `$#` — количество аргументов.
  * `$@` — аргументы как отдельные слова.
  * `$*` — аргументы как одно слово.
  * `$?` — код возврата последней команды.
  * `$!` — PID последнего фонового процесса.
  * `$$` — PID текущего shell.  

bash-special parameters:
  * `$BASH` — путь к бинарнику bash.
  * `$PPID` — PID родителя.
  * `$PWD` — текущий каталог.

Перенаправления:
  * `> file` — перезаписать stdout.
  * `>> file` — дописать stdout.
  * `2> file` — stderr → файл.
  * `2>&1` — stderr → stdout.
  * `&> file` — stdout + stderr → файл (bash).
  * `<<< "строка"` — here-string.
  * `<<EOF … EOF` — here-document.
  * `>|& file` — оба потока в файл (bash).
#### Системные утилиты:
(**_сказать не менее одного ключа_**)
  1. Работа с файлами и каталогами 
     - `ls <source>` — вывод содержимого каталога
       - `-a` - показать скрытые
       - `-l` - формат `<права> <количество hardlink> <user> <group>  <Размер> <Дата> file.txt`
       - `-i` - добавляет inode
     - `ln [-s]` - создать Hardlink\Symlink
     - `cp -R <source> <dest>` — копирование файлов/каталогов
     - `mv -R <source> <dest>` — перемещение/переименование
     - `rm -fr <source>` — удаление файлов/каталогов
     - `mkdir -p` / `rmdir -f` — создание и удаление каталогов
     - `stat` / `file` — информация о файлах
     - `find` — поиск файлов
       - `-name <pattern>` - шаблон
       - `-type [f|d|l]` — тип файла
       - `-size` — размер
       - `-[a|m|c]time [+|-]N` — время 
       - `-exec команда {} \;` — применить команду ко всем найденным.
     2. Просмотр и обработка содержимого файлов
     - `cat` — вывод содержимого
     - `head`, `tail` — первые/последние строки
     - `grep <pattern>` — поиск по содержимому
     - `wc` — подсчёт строк, слов, символов
     - `cut`, `sort`, `uniq`, `tr` — базовая обработка текстовых данных
     6. Архивация и сжатие
     - `tar`, `gzip`, `bzip2`, `zip`, `unzip` — работа с архивами
     7. Информационные утилиты
     - `df` — свободное место на дисках
     - `du` — размер файлов/каталогов
     - `uptime` — время работы системы
     - `dmesg` — сообщения ядра
     - `uname` — информация о системе

3)




4. Сетевые утилиты
- `ping` — проверка доступности узла
- `ifconfig` / `ip` — настройка сети
- `netstat` / `ss` — состояние соединений
- `wget`, `curl` — загрузка данных
- `scp`, `ssh` — удалённый доступ и передача файлов

5. Управление пользователями и правами
- `who`, `w`, `id` — информация о пользователях
- `passwd` — смена пароля
- `chmod`, `chown`, `chgrp` — управление правами доступа
- `su`, `sudo` — выполнение команд от имени другого пользователя
3. Управление процессами
- `ps` — список процессов
- `top` / `htop` — мониторинг процессов в реальном времени
- `kill`, `pkill`, `killall` — завершение процессов
- `nice` / `renice` — изменение приоритета процессов
1) OS level и компоненты
2) init, текущий init
3) PID
4) Что такое userspace, kernelspace? Чем они отличаются?
2) POSIX
3) SIG kill
3) Что такое системные вызовы?
4) process (статусы;proc/PID/;)
5) Как процессы в системе взаимодействуют между собой?
3) process vs thread
1) 
2) 
2) Что такое процесс? Что такое тред?
8) Какие алгоритмы планирования ресурсов в linux
1) top
2) LA CPU pinning
3) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности.
2) Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
3) RAM: структура; swap; утилиты; оом киллер
3) Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?
4) Что такое разделяемая память?
3) HDD: WA, блочные/символьные, 
4) Что такое major and minor numbers блочных устройств, чему они соответствуют?
5) Файловые системы, vfs, RAID, lvm, loop devices
6) 
6) inode - что это и где находятся физически.
7) hardlinks vs symlinks; как создать?
7) Где хранится информация об именах файлов, директорий?
6) Как создать файловую систему на блочном устройстве?
7) Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?
7) Каким образом осуществляется монтирование ФС?
8) Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?
2) Как определить, на каком физическом жёстком диске находится раздел с файловой системой?
3) Как узнать, какими процессами используется раздел?
4) При создании нового файла система возвращает ошибку no space left device
5) При создании нового файла пользователем система возвращает ошибку no space left on device
6) Приложение пишет в логи too many opened files.
7) df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)

1) Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли?
2) Как работает система разграничения доступа к файлам в linux? Какие возможности она предоставляет?
3) Основы bash ($,export,stdout,sudo,кавычки); a=5; true | { true && a=10; } чему будет равно a?
4) Файловые дескрипторы.
5) Как узнать что и куда пишет процесс (fd,stdout).
6) Как заставить приложение перестать писать в файл, не завершая процесс?
6) В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?
6) Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?
7) Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?
8) Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)
9) База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?







# Сеть


Статусы сетевого интерфейса.


Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?