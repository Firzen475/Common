# Железо
3) kvm IPMI что это и в чём разница.
4) Этапы загрузки ОС
5) BIOS, UEFI, PXE
2) Информация о железе в Linux (директория и утилиты)
# OC
## Всё о загрузке linux
   1) Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.
   2) Что такое уровни выполнения (run levels) в Linux
   3) Какие основные части компоненты включает в себя система на базе дистрибутива linux?
   4) Что такое BIOS, UEFI? Основы и различия
   5) Что такое PXE? Как загрузиться по сети?
   6) Что такое ядро, initramfs, загрузчик?
   7) Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах?
   8) Что такое systemd и init ? В чем основное преимущество первого над вторым?
   9) Как понять используется ли в системе systemd?
   10) Какие алгоритмы планирования ресурсов в linux ты знаешь  

## Ответ:

1) После запуска ПК загружается (из ПЗУ на материнской плате) низкоуровневое ПО BIOS или UEFI.  

BIOS (Basic Input/Output System):
  - режим 16 бит
  - поддерживает MBR-размета (максимум 2 ТБ)
  - последовательная инициализация
  - передаёт управление первым секторам диска (MBR раздел)
UEFI (Unified Extensible Firmware Interface):
  - режим 32\64 бита
  - поддержка GPT-разметка (> 2 ТБ)
  - параллельная инициализация
  - ищет и запускает исполняемые файлы .efi в FAT разделе ESP (EFI System Partition)
----
### 2) PXE или GRUB  

PXE (Preboot eXecution Environment):
 - Клиент хранится в прошивке сетевой карты или UEFI
 - Делает широковещательный запрос и получает от DHCP (Dynamic Host Configuration Protocol) адрес TFTP (Trivial File Transfer Protocol) 
 - Скачивает с сервера и загрузчик (pxelinux.0/grubx64.efi) и grub.cfg.
 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs)).
 - В параметрах ядра указывается расположение iso и cloud-init.
 - Загрузка ядра в память и передача управления.

GRUB (GRand Unified Bootloader):
  - (MBR) Stage 1 ищет Stage 2 на диске
  - (GPT) Stage 1 запуск исполняемого .efi
  - Stage 2 - Из grub.cfg получает (меню выбора OS; расположение ядра Linux (vmlinuz) и initrd (initramfs))
  - Загрузка ядра в память и передача управления.

-----
### 3) Инициализация  

#### Общее:
- Этап initrd:
  - Ядро монтирует минимальную виртуальную файловую систему в оперативку из initramfs.
  - В ней содержатся утилиты и драйвера для подготовки оборудования.
  - Монтирование корневой файловой системы (параметр ядра root=/dev/sda1)
  - Переключается на rootfs.
  - Запуск PID 1 (/sbin/init)

- Список runlevel:
  - 0 - Выключение
  - 1 - Одно пользовательский режим
  - 2 - Многопользовательский без сети.
  - 3 - Многопользовательский с сетью (режим сервера)
  - 4 - Не используется
  - 5 - Графический режим
  - 6 - Перезагрузка

#### SysV init:  
- Конфиги сервисов (unit): `/etc/init.d/` (sh скрипты)
- Метод старта сервисов (target): 
  - Символические ссылки на скрипты, соответствующие runlevel. (`/etc/rc.d/rc[runlevel].d/`)
- Управление:
  - `runlevel [N]` - текущий runlevel  переключение.
  - `service`,`service <service>` - информация о сервисах.
  - `/etc/init.d/<service> [start|stop|restart|reload|status] <job>` - управление сервисами.
- Логи: Средствами сервисов.

#### Upstart (Ubuntu до ubuntu 14.10):  
- Конфиги сервисов (unit): `/etc/init/`
  - Типы:
    - `task` - Единоразовый вызов
    - `service` - Отслеживание состояния
  - Возможности:
    - Управление порядком запуска.
    - `initctl emit my-custom-event` - Собственные события в сервисах
    - `respawn` - Автоматический перезапуск
- Метод старта сервисов (target): 
  - Генерация событий при изменениях в системе:
    - Файловые системы смонтированы -> filesystem
    - Устройства обнаружены -> udev
    - Сетевые интерфейсы подняты -> networking
    - Сервис запущен\остановлен -> started \<service> \ stopped \<service>
    - Система перешла в определённый уровень работы -> runlevel [N]
- Управление:
  - `initctl list`,`initctl status <service>` - информация о сервисах.
  - `initctl [start|stop|restart|reload] <service>` - управление сервисами.
- Логи (при добавлении в конфиги `console log`):
  - `tail -f /var/log/upstart/<service>.log`

#### <span style="color: red;">Systemd:</span>
- Конфиги сервисов (unit): `/etc/systemd/system/`, `~/.config/systemd/user/`
  - Типы:
    * `.target` - узел загружен когда загружены все его зависимости.
    * `.service` - демоны.
    * `.timer` - задачи по расписанию.
    * `.socket` - отложенный запуск при обращении к сокету.
    * `.path` - отложенный запуск при изменении файлов в директории.
    * `.mount\.automount` - Монтирование (по запросу).
    * `.swap` - Управление swap-разделами.
    * `.slice` - Группировка процессов для cgroup.
  - Возможности:
    - <span style="color: red;">Доделать позже </span>
    - пробежаться по параметрам файла service
- Метод старта сервисов (target):
  * initrd.target - юниты initramfs.
  * sysinit.target - базовая инициализация (fs,net)
    * basic.target - минимальная готовая система
      * multi-user.target - пользовательские демоны
        * default.target - главная точка входа.
- Управление:
  - `systemctl daemon-reload` - перечитать сервисы.
  - `systemctl list-units`,`systemctl status <service>` - информация о сервисах.
  - `systemctl [enable|disable|start|stop|restart|reload] <service>` - управление сервисами.
  - `systemctl [reboot|poweroff|suspend|hibernate]` - Управление системой.
- Логи
  - `journalctl -u <service>` - Логи службы
  - `journalctl -f` - Режим слежения
  - `journalctl -b` - Логи текущей загрузки
----
### 4) Компоненты дистрибутива linux
  - Bootloader
  - Ядро - управляет инициализацией и взаимодействием с железом.
  - Демоны — это фоновые процессы, которые работают в системе и выполняют различные задачи без вмешательства пользователя.
  - Системные библиотеки
  - Системные утилиты:
    - [Работа с файлами и директориями](#системные-утилиты)
  - Менеджер пакетов:
    - apt
    - pkg
    - yum
  - Службы и демоны:
    - systemd
    - sshd
    - cron
    - firewalld\iptables
    - apparmor
  - [Оболочка](#оболочки):
  - Графическая подсистема
----
## Процессы
  1) Что за процессы в Linux c PID 0 и 1
  2) Что такое POSIX
  3) Что такое userspace, kernelspace? Чем они отличаются?
  4) Что такое системные вызовы? Зачем они нужны и как они работают? Какие системные вызовы знаешь (5-10)
  5) Где можно найти информацию о конкретном системном вызове?
  6) Что делает команда kill?
  7) Что такое процесс? Что такое тред? В чем заключаются их главные отличия?
  8) Где в linux хранится информация о процессах?
  9) Что показывает статус процессов? Какие статусы используются в linux?
  10) Что такое зомби-процесс? Как можно создать такой процесс?
  11) Чем опасны зомби процессы, какие проблемы они могут создать?
  12) Можно ли завершить зомби процесс с помощью SIGKILL?
  13) Что такое SIGCHLD? В какой ситуации процесс может его получить?
  14) Что такое файловый дескриптор, какая информация в нем бывает?
  15) Для чего нужны сигналы? Какие сигналы используются чаще всего? (5 - 10 штук)
  16) Как осуществляется обработка сигналов? Чем отличается SIGTERM от SIGKILL?
  17) Какой сигнал получит активный процесс при нажатии Ctrl+C в консоли?
  18) Какие сигналы не могут быть проигнорированы?
  19) **Можно ли сделать так, чтобы пользователи могли получать информацию только о своих процессах?**
  20) Как процессы в системе взаимодействуют между собой?

### Процесс
  * **Процесс** — это базовая единица выполнения программ. 
  * это экземпляр программы, который выполняется в памяти с собственным состоянием и ресурсами. 
  * Программа лежит на диске как файл, а процесс — это активная программа в оперативной памяти.
  * Состояние процесса (основные):
    * `R (Running)` — выполняется или готов к выполнению (ожидает в очереди).
    * `S (Sleeping)` — спит, ждет события.
    * `D (Uninterruptible sleep)` — спит без возможности прерывания (обычно ждет I/O).
    * `T (Stopped)` — остановлен сигналом.
    * `Z (Zombie)` — завершился, но родитель не забрал его статус.
    * `I (Idle kernel thread)` - поток ядра в состоянии простоя. 
  * Дополнительные состояния
    * `<` - Высокий приоритет (nice < 0)
    * `N` - Низкий приоритет (nice > 0)
    * `+` - Процесс в foreground-группе (выполнение в реальном времени)
    * `s` - **лидер сессии** - процесс, создающий группу из зависимых процессов. При его завершении, завершаются все процессы в группе.
      * Используется в контейнеризации. Для хоста используется основная реализация, в контейнере сохраняется иерархия, но подменяются PID.
      * Основная реализация
        * `PID=100, SID=100, PGID=100` - лидер сессии имеет PID = PGID, и его сессия PID=SID
        * `PID=101, PPID=100, SID=100, PGID=101` - дочерний процесс пренадлежит сессии родителя PPID=SID, но сам создал сессию PID=PGID
        * `PID=102, PPID=101, SID=100, PGID=101` - дочерний от дочернего имеет сессию деда, но группу родителя
      * Работа с лидерами группы
        * `kill -SIGTERM [-PGID|PID]` - суть в `-`, если убить родителя, дочерние процессы скорее всего станут зомби.
      * Вызовы к ядру
        * `setsid()` - Процесс создаёт свою сессию
        * `setpgid()` - процесс создаёт свою группу в рамках сессии
    * `l` - многопоточный процесс.
  * **Потоки** - единица выполнения внутри процесса. Процесс может содержать один или несколько потоков.
    * Разделяют адресное пространство процесса, включая память, файловые дескрипторы.
    * Внутри процесса взаимодействуют напрямую без сигналов.
    * Как отличить поток от процесса:
      * Главный поток процесса
        * PID == TGID, PID == LWP. TGID - группа потоков.
        * NLWP ≥ 1 - у родительского потока.
      * Дочерние потоки:
        * PID PPID, PGID и SID равны родительскому процессу.
        * LWP - идентификатор процесса
      * /proc/<PID>/task/[<TPID>] - папка task содержит потоки (в том числе родительский)
  * **Cтек процесса** — это область памяти, которая используется для хранения временных данных, необходимых при выполнении функций и системных вызовов. 
    * Основное его назначение — поддержка управления вызовами функций и локальных переменных.

#### Управление процессами

* `kill`, `pkill`, `killall` — завершение процессов
* `nice` / `renice` — изменение приоритета процессов

#### Мониторинг
  * `ps aux` - Стандартный вывод процессов (стиль BSD без `-`)
    * `-a` - процессы всех пользователей
    * `-u` - в стандартном формате
      * USER; PID; %CPU; %MEM; VSZ(виртуальная); RSS(резидентная); TTY(терминал) STAT; START; TIME; COMMAND
    * `-x` - с демонами
  * `ps -eLf` - группировка (стиль UNIX c `-`)
    * `-e` - аналог a
    * `-L` - все потоки (LWP)
    * `-f` - полный формат
      * UID; PID(процесса); PPID; LWP(ID потока); NLWP(количество потоков) STIME TTY TIME CMD
  * Директория `/proc/[PID]/` - текущее состояние процесса
    * Общая информация (PID,GID,...)
    * Информация об исполняемом файле и cwd
    * Потребляемые ресурсы
    * Файловые дескрипторы
    * Состояние потоков
    * **Стек вызовов и текущие вызовы** (раскрыть)
    * Сетевая статистика
  * Управление процессами


#### Управление ресурсами
* `ulimit` - Позволяет ограничивать ресурсы процессов для текущей оболочки и её дочерних процессов.
* `nice` - Контролирует приоритет процесса на CPU.
* `systemd` сервисы - тонкая настройка юнита процесса через файл. Использует механизм cgroup.
  * `systemctl daemon-reload` - после изменения перечитать юниты
  * `systemctl restart myservice` - перезапустить сервис.
* `cgroups` - **Control Groups** - Позволяет тонко управлять ресурсами на уровне процессов и групп процессов.
  * `mkdir /sys/fs/cgroup/<group_name>` - создание cgroup.
  * `/sys/fs/cgroup/<group_name>/[cpu.|io.|memory.` - настройка управления ресурсами
  * `echo <PID> > /sys/fs/cgroup/<group_name>/cgroup.procs` - добавление процесса в группу

#### namespace
  * **Namespace в Linux** — это механизм изоляции, позволяющий одному ядру предоставлять разным группам процессов собственные «контексты» системы. 
  * Каждый тип namespace ограничивает видимость определённых ресурсов, создавая иллюзию отдельной системы.
  * Типы namespace:
    * **UTS** (hostname, domainname)
    * **PID** (собственная нумерация процессов)
    * **NET** (интерфейсы, маршруты, fw правила)
    * **MOUNT** (собственная таблица монтирования)
    * **IPC** (очереди, семафоры, shared memory)
    * **USER** (UID/GID mapping, привилегии)
    * **CGROUP** (видимость иерархии cgroups)
    * **TIME** (смещение системного времени)

#### Системные вызовы
  * **Системные вызовы в Linux** — это набор функций, через которые пользовательские программы обращаются к ядру операционной системы.
  * Взаимодействие пространства пользователя и пространства ядра.
  * Наиболее часто используемые
    * `open, read, write` - Работа с файлами
    * `fork, exec, wait, kill` - работа с процессами
    * `mmap, munmap` - работа с памятью
    * `pipe, mkfifo` - создание анонимного канала
    * `wait, waitpid` - родитель завершает дочерний процесс после `SIGCHLD`
    * сетевые
      * `socket` — создание сокета.
      * `bind / listen / accept` — привязка сокета, прослушивание и принятие соединений.
      * `connect` — соединение с удалённым адресом.
      * `send / recv` — отправка и приём данных.


#### IPC, Inter-Process Communication
  * **Сигналы (Signals)** - это асинхронные уведомления процесса о каком-то событии.
    * `SIGKILL(9)` - Безусловное завершение процесса.
    * `SIGTERM(15)` - Запрос на завершение процесса. Процесс может обработать сигнал и корректно закрыться.
    * `SIGINT` - Прерывание процесса с клавиатуры (Ctrl+C в терминале).
    * `SIGHUP` - перезапуск процесса
    * `SIGSTOP` - остановка процесса
    * `SIGCONT` - возобновление процесса
    * `SIGCHLD` - дочерний процесс завершен и ждёт считывания результата родителем
    * `SIGSEGV` - недопустимый доступ к памяти
  * Каналы (Pipes)
    * Анонимные каналы - взаимодействие родителя с дочерними процессами.
      * Создаются через системный вызов `pipe()`
      * Обычно используются между родительским и дочерним процессом после `fork()`.
      * Не имеют имени в файловой системе, исчезают после завершения процессов.
      * односторонний поток данных - для обратной связи нужно 2 канала.
    * Именованные каналы (FIFO) - Взаимодействие любых процессов
      * Создаются с именем в файловой системе `mkfifo`.
      * Могут использоваться любые процессы, которые знают имя канала.
      * односторонний поток данных - для обратной связи нужно 2 канала.
  * Очереди сообщений (Message Queues)
    * Плюсы:
      * Хранит сообщения в ядре.
      * Поддерживает приоритет и **типы сообщений**.
      * `ipcs -q` - мониторинг сообщений
    * Минусы:
      * Размер сообщений ограничен системными лимитами.
      * Не самый быстрый способ для больших потоков данных (лучше shared memory).
      * Нужно явно управлять удалением очереди.
  * Разделяемая память (Shared Memory) - это один из самых быстрых способов обмена данными между процессами, потому что данные не копируются через ядро (как в каналах или очередях сообщений), а сразу доступны в памяти обоим процессам.
    * Один процесс создаёт сегмент разделяемой памяти через системный вызов mmap.
    * Другой процесс также подключается к этому сегменту.
    * Оба процесса могут читать и писать в общую память напрямую.
    * Можно контролировать с помощью семафоров, чтобы избежать гонки.
  * **Семафоры (Semaphores)** - механизм блокировки на уровне кода, находится в памяти процесса или Shared Memory.
    * **Mutex - 0** - свободно, 1 - занято.
    * **Счётный семафор** - значение ≥0, позволяет ограничить число процессов, одновременно работающих с ресурсом.
  * Сокеты (Sockets) - может быть как локальным, так и сетевым. 
    * Сервер создаёт слушающий сокет — только для обнаружения новых соединений.
    * Клиентский отправляет запрос через динамический порт.
    * Когда клиент подключается, ядро создаёт новый сокет на сервере, связанный с конкретным клиентом.
      * Привязывает свой динамический порт к сокету и уже так передаёт данные через сетевой стек
  * Файлы и mmap - доступ нескольких процессов к общим страницам памяти, содержащим файл.

#### Capabilities
  * Это механизм разграничения привилегий, который позволяет предоставлять процессам только необходимые права вместо полномочий.
  * Если процесс запущен от имени пользователя, но не должен использовать часть привилегий, их можно отключить.
  * Изменить Capabilities запущенного процесса нельзя.
  * Используются в docker и kubernetes для тонкой настройки прав процесса.
  * Параметры
    * `CAP_NET_ADMIN` — управление сетевыми настройками.
    * `CAP_NET_BIND_SERVICE` - возможность биндить порты <1024 без root
    * `CAP_SYS_ADMIN` — широкие административные права (аналог многих операций root).
    * `CAP_DAC_OVERRIDE` — игнорирование прав доступа к файлам.
    * `CAP_KILL` — отправка сигналов любым процессам.
    * `CAP_SYS_TIME` — изменение системного времени.
  * Можно присвоить атрибуты на бинарник навсегда
    * `setcap CAP_NET_BIND_SERVICE+ep /usr/sbin/nginx` - пример установки атрибутов
    * `getcap [бинарник]` - текущие атрибуты
    * `capsh --decode=[HEX 000001ffffffffff]` - чтение атрибутов

#### seccomp (secure computing mode)
  * Фильтр системных вызовов, который ограничивает, какие системные вызовы может выполнять процесс.
  * Более глубокий механизм ограничения возможностей процесса на уровне запросов к ядру
  * Настраивается через файл профиля в формате `.json`
  * Используются в docker и kubernetes для тонкой настройки прав процесса.
  * По сути перехватывает системный вызов и выполняет одно из 3-x действий:
    * `SCMP_ACT_KILL` — убить процесс.
    * `SCMP_ACT_ERRNO` — вернуть ошибку (без убийства).
    * `SCMP_ACT_LOG` — только логировать нарушение.
    * `SCMP_ACT_ALLOW` — разрешить вызов.

#### AppArmor
  * AppArmor — это система Mandatory Access Control (MAC) для Linux, которая ограничивает возможности приложений, основываясь на профилях безопасности. Основная цель AppArmor — предотвратить злоупотребления программами и минимизировать последствия возможных уязвимостей.
  * фильтр ресурсов и операций с ними (файлы, сети, IPC, устройства).
  * Работает на основе профилей, есть профили для многих пакетов (процессов)
  * Автогенерация правил, через анализ взаимодействия с OS
  * Есть режимы блокировки и логирования


----
## Ресурсы и мониторинг (CPU, RAM)
  1) Как посмотреть нагрузку на диски?
  2) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?
  3) Представлен вывод команды top. Что означает каждая запись в выводе?
  4) Что такое swap файл (подкачки)? Зачем он нужен, и как он работает? Какие данные в него записываются?
  5) Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?
  6) Что такое физическая память?
  7) Что такое виртуальная память?
  8) Почему в htop может быть не до конца корректная сводка по потребляемой памяти
  9) Где в системе можно посмотреть сводку по текущему потреблению памяти?
  10) Как работает оом киллер и для чего нужен? Out of memory, oom
  11) Что такое iowait и почему он может появляться?
## Ответ:
#### CPU:
  * Можно посмотреть 3-мя показателями: Load average (LA); PSI some CPU; Колонка %CPU
    * `Load average` - Среднее количество процессов в очереди (состояние D(uninterruptible sleep)) за 1, 5, 15 мин
    * `PSI CPU` - Время, простоя из-за конкуренции
      * `some` - хотя бы один runnable-поток не получил ресурс. `(avg10 ≈ (1.5 / 10) * 100% = 15%)`
      * `full` - все потоки ожидают ресурс. 
    * `%CPU` - количество загруженных ядер одним процессом (100% = 1ядро)
  * Load average учитывает процессы, ожидающие iowait(взаимодействие с диском)
  * Измеряется в виртуальных ядрах (0.5 ядра = 50% = 0.5m)
### RAM:
  * Физическая память (ОЗУ) - установленная RAM, линейно адресуемая.
    * линейно адресуемая - ячейка имеет адрес и доступна и обращение напрямую
    * frame - Разбита на фреймы соответствующая размеру Page
  * Виртуальная память (ОЗУ+swap) - память, расширенная за счёт swap, с защитой и изоляцией процессов.
  * Виртуальный адрес - адрес страницы в виртуальной памяти, который транслируется в физическую по Page Table.
    * `malloc()` - резервирование адресного пространства.
    * `mmap()` - системный вызов создаёт адрес в виртуальной памяти и трансляцию в физическую. 
    * `[ PML4 index | PDPT index | PD index | PT index | offset ]` - виртуальный адрес или координаты в Page Table
  * `Page Table` - набор со зависимых таблиц, по которым читаются данные. Находятся всегда в физической памяти.
    * `PML4` - главная таблица с фиксированным адресом
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
    * `PDPT` - таблица содержит либо ссылки на таблицы PD, либо вся запись является большой страницей (1Gb)
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
      * `PS=1` - вся запись это страница
    * `PD` - таблица содержит либо ссылки на таблицы PT, либо вся запись является большой страницей (2МБ)
      * `Present [0|1]` - запись существует.
      * `RW/User` - права и владелец записи.
      * `PS=1` - вся запись это страница
    * `PT` - записи содержат страницы (4КБ)
      * `Page Entry` - если записи являются страницами, а не ссылками, то они имеют флаги `(PDPT,PD,PT)`
        * `Read/Write (RW) [0|1]`
        * `User/Supervisor (U/S)`
        * `Accessed` - страница была использована и можно её удалять
        * `Dirty` - страница изменена и требует сохранения в swap при вытеснении.
        * `NX (No Execute)` - флаг запрета на исполнение. Напрямую связан с chmod +x.
    * `CoW` - Новые страницы создаются при изменении (нужно раскрыть с примером).
### OOM Killer:
  * Механизм, который завершает процесс при нехватке памяти.
  * `oom_score` - стоимость процесса, наибольший завершается первым
    * объём потребляемой памяти
    * приоритет (oom_score_adj)
    * принадлежность к пользователю/системе
    * важность для работы ядра
  * Управление:
    * `/proc/<pid>/oom_score` — текущая оценка процесса. 
    * `/proc/<pid>/oom_score_adj` — ручная корректировка от -1000 до 1000.
  * Мониторинг:
    * dmesg или /var/log/kern.log
#### Управление
  * **cgroup** и управление ресурсами
    * Добавление
      * `/sys/fs/cgroup/<group name>/cgroup.procs`
      * `/sys/fs/cgroup/<group name>/cgroup.controllers`
    * Управление
      * `/sys/fs/cgroup/<group name>/cpu.[max|weight|stat]` - Управление и статистика по CPU.
      * `/sys/fs/cgroup/<group name>/memory.[max|high|min|low|stat]` - Управление и статистика по RAM.
      * `/sys/fs/cgroup/<group name>/io.[max|weight|stat]` - Управление и статистика по I/O.
      * `/sys/fs/cgroup/<group name>/pids.[max|current]` - Ограничение на процессы и статистика.
      * `/sys/fs/cgroup/<group name>/pressure/[cpu|memory|io].pressure` - PSI (Pressure Stall Information)
  * **swap** 
    * `swapon /swapfile` `swapoff /swapfile` - включение и отключение
    * `/proc/sys/vm/swappiness` - настройка агрессивности использования `swap` для всей системы

#### Мониторинг
  * `top\htop` - мониторинг CPU и RAM
  * `/proc/uptime` - 2 значения -> Общее время работы системы, Суммарное время "простоя" (idle_time) всех CPU (также в секундах).
  * `/proc/loadavg` - 5 значений -> la_1, la_5, la_15, Активные/общие процессы, Последний использованный PID

|          |       |         |              |                              |          |                           |                           |                              |      |      |         |
|----------|-------|---------|--------------|------------------------------|----------|---------------------------|---------------------------|------------------------------|------|------|---------|
| top      | up    | users   | load average |
| Tasks:   | total | running | sleeping     | zombie                       |
| %Cpu(s): | us    | sy      | ni(nice)     | id(idle)(Простой процессора) | wa       | hi(аппаратные прерывания) | si(софтверные прерывания) | st («украдено» гипервизором) |
| Mem:     | total | free    | used         | buff/cache                   |
| Swap:    | total | free    | used         | avail                        |
| PID      | USER  | STATUS  | PRI          | NI                           | DISC R/W | VIRT                      | RES                       | SHR                          | MEM% | CPU% | COMMAND |
----
## Файловые системы и их организация
  1) Что такое блочные устройства? Какие элементарные операции можно с ними производить?
  2) Что такое символьные устройства? Какие элементарные операции с ними можно производить?
  3) Что такое major and minor numbers блочных устройств, чему они соответствуют?
  4) Что такое файловая система? Для чего она нужна?
  5) Как создать файловую систему на блочном устройстве? Какие параметры можно задать при создании?
  6) Что такое inodes айноды
  7) Где физически находятся inodes айноды
  8) По какой причине и на какого типа системах айноды могут закончиться? И к чему это может привести?
  9) Какая файловая система бывает динамическими айнодами и что это такое, зачем нужно?
  10) Где хранится информация об именах файлов, директорий?
  11) Каким образом осуществляется монтирование ФС? Как можно посмотреть список примонтированных ФС?
  12) Что такое псевдофайловая система?
  13) Какие проблемы могут возникать с файловой системой и жёстким диском? Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?
  14) Какую файловую систему выбрать ext4 или xfs?
  15) Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?
  16) Как узнать, какими процессами используется раздел?
  17) Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?
  18) Что такое RAID? Какие основные типы RAID существуют, чем они отличаются?
  19) Какие средства для работы с программными RAID массивами существуют в linux?
  20) Что такое LVM? Для решения каких задач он предназначен?
  21) Что такое loop devices? Как их можно использовать?
  22) При создании нового файла система возвращает ошибку no space left device
  23) df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)
  24) При создании нового файла пользователем система возвращает ошибку no space left on device
  25) В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?
  26) Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?
  27) Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)
## Ответ:
### Физическая организация (RAID)
  * Символьные устройства
    * Клавиатура, мышь, последовательный порт.
    * Передача данных побайтно, медленные.
  * Блочные устройства
    * Любые устройства хранения, которые можно разбить на блоки. Доступ к блокам происходит независимо.
    * Сюда входят RAM-диски, компакт-диски, дискеты
    * Монтируются в `/dev/`
    * Посмотреть можно через `lsblk` `lspsi`
    * Управляются контроллерами через драйвера.
      * если выполнить `ls /dev/` - мажорные(драйвер) минорные(порядковый номер) номера - объяснить

  * `RAID 0` - Чередование
    * Описание
      * Требуется минимум 2 диска.
      * Все диски объединяются в общее пространство. Используется вся память.
    * Плюсы
      * Высокая скорость записи (кратно количеству) - можно писать параллельно на несколько дисков.
    * Минусы
      * Нет отказоустойчивости.
  * `RAID 1` - Зеркалирование
    * Описание
      * Требуется количество дисков кратное 2.
      * Данные записываются дважды на оба диска.
      * Скорость сопоставима с обычным диском.
    * Плюсы
      * При сбое данные копируются с зеркала. Идеальная отказоустойчивость
    * Минусы
      * Эффективная ёмкость равна половине от фактической.
  * `RAID 5` - Одинарная точность
    * Описание
      * Требуется 3-16 дисков
      * Расчёт и восстановление: `P = D1 XOR D2 XOR D3` -> `D1 = P XOR D2 XOR D3`
    * Плюсы
      * Выдерживает отказ 1
      * Эффективная ёмкость = (N – 1) × размер_диска
    * Минусы
      * Запись медленнее из-за расчёта чётности
      * Лавинный отказ при восстановлении
    * `RAID 6` - Двойная точность
      * Описание
        * Требуется минимум 4 диска
        * Расчёт `P = D1 XOR D2 XOR D3` `Q = a1*D1 ⊕ a2*D2 ⊕ a3*D3`
      * Плюсы
        * Выдерживает отказ 2
        * Эффективная ёмкость = (N – 2) × размер_диска
        * Высокая надёжность с малыми потерями ёмкости
        * Вероятность выхода из строя 2 дисков минимальна
      * Минусы
        * Скорость записи до 20% ниже из-за расчёта чётности
        * Долгое восстановление
    * `RAID 10`
      * Описание
        * Комбинация `RAID 1` и `RAID 0` - сначала зеркалируются, потом дублируются
      * Плюсы 
        * Все плюсы `RAID 1` и `RAID 0`
      * Минусы
        * Дорого
#### Управление
  * через контроллеры с собственным буфером (своя оперативная память и самостоятельный расчёт чётности)
    * Диски подключаются к контроллеру
    * Получившийся диск монтируется как обычный диск.
  * `mdadm` - программный рейд 
    * Объединяет разделы или диски в рейд и управляет логикой записи.
    * При инициализации на этапе init, можно использовать как root раздел
    * `/etc/mdadm/mdadm.conf` - настройки программного рейда
#### Мониторинг
  * `cat /proc/mdstat` - состояние рейда
  * `mdadm --detail /dev/md0` - информация о рейде
  * Логи сборки
    * `journalctl -k | grep md`
    * `dmesg | grep md`
  * Можно настроить уведомления на почту

### Файловые системы
Файловая система — это способ организации данных на диске, который разделяет данные на отдельные части, называемые файлами. Она также управляет метаданными этих файлов, такими как их имена, разрешения и другие атрибуты.
#### Виды файловых систем
  * **Псевдофайловая система** - это виртуальная файловая система в Linux, которая не хранит реальные данные на диске, а предоставляет интерфейс для взаимодействия с ядром и различными устройствами через привычную файловую структуру.
    * `/proc` - Содержит информацию о процессах и состоянии системы
    * `/sys` - Отображает устройства, драйверы и различные подсистемы ядра.
      * `/sys/class/net/` - сетевая информация
      * `/sys/block/` - блоковые устройства
    * `/dev` - Содержит устройства, управляемые через udev
    * `/run` или `/var/run` - Временная файловая система (tmpfs - хранится в RAM) для хранения временных данных, таких как PID-файлы или сокеты
  * Локальные, журналирование
    * `NTFS` - используется в Windows, поддержка ACL и шифрования
    * `ext3/ext4` - лучше для мелких файлов
    * `XFS` - лучше для больших файлов
    * `JFS` - лучше для очень слабых систем
  * CoW (snapshots) - серверные fs для файловых хранилищ с высокой надёжностью
    * `Btrfs` - более лёгкая 
    * `ZFS` - имеет встроенный программный рейд, аналогичный RAID5-6. Сама управляет восстановлением рейда. Свой аналог LVM. Комбайн - всё в одном.
  * Файловые системы для флеш-памяти и встроенных устройств
    * `F2FS` - меньше нагрузка на ssd
    * `JFFS2` - используется в роутерах
  * Сетевые
    * `NFS`
    * `SMB/CIFS`

#### ext4

```shell
(FS)
  ├── Superblock - находится в начале раздела и дублируется в блоках
     ├── (Полный размер, размер блока, размер группы блоков, количество групп)
     ├── Group Descriptor Table - ссылки на Block Group
        ├── GroupDesc[0] -> (BlockBitmap0, InodeBitmap0, InodeTable0)
        ├── GroupDesc[1] -> (BlockBitmap1, InodeBitmap1, InodeTable1)
        ├── GroupDesc[2] -> ...
     ├── Block Group N - группа блоков ([размер блока]*[размер группы блоков])
        ├── Superblock copy
        ├── Group descriptor copy
        ├── Block Bitmap - битовая карта блоков
        ├── Inode Bitmap - битовая карта inode
        ├── Inode Table [] - Таблица с метаданными о файле (inode)
            ├── Размер файла
            ├── Тип и права
            ├── UID / GID
            ├── Временные метки
                ├── ctime - создание
                ├── mtime - изменение
                ├── atime - доступ
                ├── crtime - время создания файла (если поддерживается)
            ├── Счётчик ссылок (i_links_count)
            ├── Флаги
                ├── i — immutable
                ├── a — append-only
                ├── A — no atime updates
                ├── d — no dump
            ├── Extents [] - карты расположения данных
                ├── Extent 1: start=10, length=4
                ├── Extent 2: start=20, length=8
        ├── Directory Entries (если inode — каталог)
            ├── filename1 -> inode X
            ├── filename2 -> inode Y
        ├── Extended Attributes (xattr)
            ├── POSIX ACL
            ├── и д.р.
        ├── Data Block [] - фактические блоки на диске, на которые ссылается Extent 
            ├── Data Block 10...14 
            ├── Data Block 20...28

```

#### INODE
  * **Inode (индексный дескриптор)** - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Но не имена файлов.
  * Занята пока существует хотя-бы одна жесткая ссылка. Отслеживается параметром i_links_count
  * для быстрого поиска свободных используется битовая карта.
  * Если свободные Inode закончились - поможет увеличение диска.
  * Файловые системы с динамическими inode - `XFS`, `ZFS`, `BTRFS`
  * Существует понятие тип файлов:
    * `-` - Обычные файлы
    * `d` - Каталоги
    * `l` - Символические ссылки
    * `b` - Файлы-устройства блочные
    * `c` - Файлы-устройства символьные (tty, serial, input)
    * `p` - FIFO (именованные каналы) -> раскрыть
    * `s` - Сокеты

#### hardlinks symlinks
  * hardlinks - aльтернативная ссылка на ту-же inode
    * -rw-r--r--  2(2 хардлинка) root     root     0B Aug 13 11:51 file1
    * Работает только в рамках файловой системы
  * symlinks - имеет свою inode и свои атрибуты, но исполняет или открывает файл, на который ссылается.
    * lrwxr-xr-x  1 root     root     5B Aug 13 12:02 symlink1 -> file1
    * может ссылаться на файлы вне файловой системы

#### Управление
  * `mkfs -t ext4 /dev/sdb1` - создание файловой системы в разделе
    * `-L <label>` - метка файловой системы.
    * `-b block-size` - задает размер блока в байтах (по умолчанию 4096).
    * `-N number-of-inodes` - задает количество индексных дескрипторов (inode) для экономии места для хранения inode
    * `-i <количество байт>` - создаст один inode на заданное количество байт пространства. Если ожидается много мелких файлов.
  * `mount <source> <dest>` - Утилита ручного монтирования файловой системы.
    * `-t [ext4|vfat|ntfs]` - указывает тип
    * `-o` - дополнительные параметры, например 
      * `rw,noexec` - чтение\запись, запрет на запуск файлов из этой файловой системы
  * `/etc/fstab` - файл для автоматического монтирования файловых систем после загрузки
  * 

#### Восстановление
  * Проверки проходят в одно пользовательском режиме (telinit 1) или через LIVE-CD.
  * `fsck[.ext4|.xfs|.vfat|.btrf] <source>` - утилита автоматического восстановления.
    * `-A` — проверить все файловые системы, указанные в /etc/fstab.
    * `-VС` — verbose и вывод прогресса проверки.
    * `-N` - dry run
  * Специализированные утилиты под другие fs не представлены.

#### Мониторинг
  * Файлы
    * `lsof <source>` - показывает PID, USER, FD, ACCESS, inode, DEVICE (major, minor)
    * `file <source>` - тип файла по расширению
    * `stat <source>` - данные из inode
    * `fuser <source>` - PID процессов использующих файл (файловые дескрипторы)
  * Монтирование
    * `/etc/mtab` – это файл, который содержит список уже смонтированных файловых систем.
    * `mount` - список смонтированных файловых систем
      * `-t [ext4|vfat|ntfs]` - фильтр по типу файловой системы
    * `dmesg`

### LVM
**LVM (Logical Volume Manager) в Linux** — это система управления дисковым пространством, которая делает работу с разделами более гибкой по сравнению с обычными разделами на дисках. Основная идея — разделить физические носители на логические уровни, чтобы можно было легко изменять размеры, объединять или переносить хранилища без простоя системы.
  * Процесс создания
    * `fdisk /dev/<disk>` - утилита для создания разделов
      * `n` — создать новый раздел
      * Partition type:
        * `p` — Primary: сделать его первичным может быть загрузочным (легаси MBR раскрыть)
        * `e` — Extended: контейнер для логических разделов
          * `l` — Logical: логический раздел
      * `w` — записать изменения и выйти
    * `fdisk -l /dev/<disk>` - Проверка разделов
    * `pvcreate /dev/<disk><part>` - создание **Physical Volume (PV)**. PV может находиться только в одной VG
    * `pvdisplay` - статус PV
    * `vgcreate <vg_name> /dev/<disk><part>` - создание **Volume Group (VG)**  добавление в него PV
    * `vgdisplay` - статус VG
    * `lvcreate <vg_name>` - **Logical Volume (LV)** в рамках VG
      * `-n <lv_name>`
      * `-L 50G`
    * `lvdisplay`
    * `mkfs.ext4 /dev/<vg_name>/<lv_name>` - Форматируем LV в файловую систему ext4
    * `mount /dev/<vg_name>/<lv_name> /home` - монтируем
  * Расширение
    * `vgextend vg_data /dev/sdc1` - добавляем раздел в группу
    * `lvextend /dev/<vg_name>/<lv_name>` - расширяем логический раздел
      * `-L +20G` - на 20Gb
      * `-l 100%FREE` - на 100%
    * `resize2fs /dev/<vg_name>/<lv_name>` - применение расширения для ext4

### Loop device
**Loop-устройства (loop devices)** — это виртуальные блоковые устройства в Linux, которые позволяют работать с файлом как с блочным устройством, например с диском или разделом.
  * Создание образа через loop devices
    * `dd` - утилита для поблочного копирования данных.
      * `if=/dev/zero` - источник копирования. Может быть реальным диском /dev/sd[N].
      * `of=disk.img` - приёмник. Результирующий файл.
      * `count=2048` - размер приёмника MB (используется при /dev/zero)
      * `status=progress` 
    * `losetup disk.img` - привязка образа к loop устройству. 
      * -f - использовать свободное
      * -P - Разделы доступны как `/dev/loop[i]p[j]`
    * `fdisk` - Разбиваем на разделы
    * `mount /dev/loop[i]p[j] /mnt_test` - монтируем требуемые разделы
    * `debootstrap /mnt_test` - утилита (для debian) устанавливает минимально необходимые пакеты (base)
      * `--arch amd64` - архитектура
      * `focal` - версия OS
      * `http://archive.ubuntu.com/ubuntu/` - источник base
    * Проброс текущей системы
      * `mount --bind /dev /mnt_test/dev` - устройства (/dev/null, /dev/zero, сеть)
      * `mount --bind /proc /mnt_test/proc` - процессы (как минимум нужен PID-0 и PID-1)
      * `mount --bind /sys /mnt_test/sys` - параметры ядра
    * `chroot /mnt_test` - переключение контекста.
    * Настройка
      * `apt install` - Стандартная установка программ 
      * `/boot/grub/grub.cfg` - настройка параметров загрузки
      * `/etc/sysctl.conf` - настройка ядра.
    * `exit` - выход из контекста
    * `umount /mnt_test/dev /mnt_test/proc /mnt_test/sys` - отключения проброса
    * `dd if=linux.img of=/dev/sdX status=progress` - Загрузка образа на носитель

----
## Bash и его утилиты
   1) В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?
   2) Что значит $@, $!, $?, $$ в bash?
   3) Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?
   4) При перенаправлении команд (command1 | command2 ) перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?
   5) В чем разница между одинарными кавычками (') и двойными кавычками (")?
   6) a=5; true | { true && a=10; } чему будет равно a?

## Ответ:
  ОС на базе Linux имеют оболочки (терминал для исполнения команд) и набор встроенных утилит.  
#### Оболочки:
  - bash
  - ash
  - zsh
  - sh  
#### Принцип работы
  * Каждая сессия терминала это процесс. При выполнении команды выполняется POSIX команда `fork()`  
  * `fork()` создаёт копию процесса (память, переменные) и вызывает `execve()` для запуска утилиты  
  * Родитель ожидает получения `SIGCHILD` и результата выполнения в виде `stdout stderr` (файловые дескрипторы 1 и 2)
  * Дочерний процесс **видит** переменные родительского.  
  * Можно выстраивать цепочки команд (`pipe`) `command1 2>&1 | command2`  
  * _рассказать про кавычки_
#### Параметры и системные переменные
POSIX-special parameters:
  * `$0` — имя скрипта или shell.
  * `$1…$N` — позиционные параметры.
  * `$#` — количество аргументов.
  * `$@` — аргументы как отдельные слова.
  * `$*` — аргументы как одно слово.
  * `$?` — код возврата последней команды.
  * `$!` — PID последнего фонового процесса.
  * `$$` — PID текущего shell.  

bash-special parameters:
  * `$BASH` — путь к бинарнику bash.
  * `$PPID` — PID родителя.
  * `$PWD` — текущий каталог.

Перенаправления:
  * `> file` — перезаписать stdout.
  * `>> file` — дописать stdout.
  * `2> file` — stderr → файл.
  * `2>&1` — stderr → stdout.
  * `&> file` — stdout + stderr → файл (bash).
  * `<<< "строка"` — here-string.
  * `<<EOF … EOF` — here-document.
  * `>|& file` — оба потока в файл (bash).
#### Системные утилиты:
(**_сказать не менее одного ключа_**)
  1. Работа с файлами и каталогами 
     - `ls <source>` — вывод содержимого каталога
       - `-a` - показать скрытые
       - `-l` - формат `<права> <количество hardlink> <user> <group>  <Размер> <Дата> file.txt`
       - `-i` - добавляет inode
     - `ln [-s]` - создать Hardlink\Symlink
     - `cp -R <source> <dest>` — копирование файлов/каталогов
     - `mv -R <source> <dest>` — перемещение/переименование
     - `rm -fr <source>` — удаление файлов/каталогов
     - `mkdir -p` / `rmdir -f` — создание и удаление каталогов
     - `stat` / `file` — информация о файлах
     - `find` — поиск файлов
       - `-name <pattern>` - шаблон
       - `-type [f|d|l]` — тип файла
       - `-size` — размер
       - `-[a|m|c]time [+|-]N` — время 
       - `-exec команда {} \;` — применить команду ко всем найденным.
     2. Просмотр и обработка содержимого файлов
     - `cat` — вывод содержимого
     - `head`, `tail` — первые/последние строки
     - `grep <pattern>` — поиск по содержимому
     - `wc` — подсчёт строк, слов, символов
     - `cut`, `sort`, `uniq`, `tr` — базовая обработка текстовых данных
     6. Архивация и сжатие
     - `tar`, `gzip`, `bzip2`, `zip`, `unzip` — работа с архивами
     7. Информационные утилиты
     - `df` — свободное место на дисках
     - `du` — размер файлов/каталогов
     - `uptime` — время работы системы
     - `dmesg` — сообщения ядра
     - `uname` — информация о системе

  


### Общее
#### Пользователи и профили
  * **пользователь** — это учетная запись, которая позволяет идентифицировать человека или процесс в системе и управлять его доступом к ресурсам.
  * Управление:
    * useradd - утилита создания пользователя
    ```shell
    useradd ivan \
      # def домашняя директория | указать               | шаблон       | сервисный
      -m                        | -d /custom/home/ivan  | -k /etc/skel | -r \
      # Оболочка   | без оболочки
      -s /bin/bash | -s /dev/null \
      # основная группа | без группы | доп группы
      -g developers     | -N         | -G sudo,docker  \
      # задать uid
      -u 1500 \
      # срок действия
      -e 2025-12-31 
      # пароль
      -p '$6$salt$hash'
    ```
    * usermod - утилита изменения
    * userdel - утилита удаления
    * passwd - задать пароль
  * Профили - файлы со скриптами, выполняемые при входе в окружение. Аналог автозагрузки в Windows.
    * `/etc/profile, /etc/profile.d/` - общие скрипты. (интерактивно `sudo -i | su -`)
    * `~/.profile` - пользовательские. (интерактивно `sudo -i | su -`)
    * `~/.bash_profile` - пользовательские, если bash. (интерактивно `sudo -i | su -`)
    * `~/.bashrc` - пользовательские, если bash. (не интерактивно `sudo -s`)
  * /etc/shadow
  * /etc/group

#### Права доступа, umask
  * Порядок предоставления доступа к файлу:
    * проверка на владельца
    * проверка участия в группе
    * предоставление прав other
  * r 4 чтение
  * w 2 запись
  * x 1 выполнение (для каталогов возможность открыть)
  * Пример:
    * rwx = 4+2+1 = 7
    * rw- = 4+2+0 = 6
    * r-x = 4+0+1 = 5
  * Варианты команд - раскрыть и упомянуть, почему + и -
    * chmod 644 file.txt
    * chmod u+x script.sh 
    * chmod g-w file.txt
  * Специальные биты
    * SUID (4) - Файл запускается с правами владельца файла, а не запускающего пользователя.
    * SGID (2):
      * Для файлов: запуск идёт с правами группы файла.
      * Для каталогов: все новые файлы внутри каталога наследуют группу каталога.
    * Sticky bit (1) - Файлы внутри каталога могут удалять или переименовывать только: 
      * владелец файла
      * владелец каталога
      * root
    * Установка всех специальных бит
      * 7777 -> rw**s**rw**s**rw**t** | drw**s**rw**s**rw**t**
  * В kubernetes следует указывать права в восьмеричном (hex) формате
    * 0744 - верно, 744 - не верно
  * umask - утилита устанавливает маску прав для создаваемых файлов и директорий.
  * у файла 666, у директории по умолчанию 777, что сохраняет исполняемый бит
    * `umask 027` - даст `rw-r----- | drwxr-x---`
    * обычно добавляется в `/etc/profile` или `~/.bashrc`
  * `chmod`, `chown` — управление правами доступа

#### sudo visudo(sudoers)
  * `visudo` - управления правами пользователя, открывает `/etc/sudoers`
  * /etc/sudoers - файл для настройки прав пользователя, позволяет выдать гибкие привилегии.
    * `user ALL=(ALL) ALL` - root права
    * `user ALL=(root) NOPASSWD:/usr/bin/systemctl restart nginx` - рут права без пароля для `restart nginx`
  * Sudo (substitute user and do) - позволяет подменить пользователя и выполнить команду от его имени.
    * По умолчанию выполнение команды происходит от имени суперпользователя.
    * Основная идея: 
      * пользователю предоставляется права на повышение через `/etc/sudoers`. (можно ограничить набор разрешений)
      * с паролем текущего пользователя получаешь другие привилегии
      * Логирует каждую команду (контроль и аудит).
      * Сохраняет окружение текущего пользователя (PATH, env, profile)
      * Дополнительно
        * sudo -i - загружает логин-окружение → ~root/.bash_profile, переменные среды root, его PATH, алиасы и т.д.
        * sudo -s - Просто даёт root-оболочку, не переключая окружение. (например выполнить несколько команд подряд)
  * su (switch user) - Полностью переключает на указанного пользователя. загружает окружение, требует пароль этого пользователя.


* Содержимое файлов в `/proc/`

### Задачи
* Как работает система разграничения доступа к файлам в linux? Какие возможности она предоставляет?
  * Проверяет inode: rwx пользователь -> группа -> гость
  * Рассказать про права: rwx, umask, Специальные биты, chmod.
* Как работает sudo? Для чего она используется?
  * sudo(-i, -s, -u), visudo(/etc/sudoers), su (-), profile, окружение.
* Приложение запущено как сервис - как посмотреть то, что оно написало в stdout?
  * journalctl, lsof, strace, связь с файловыми дескрипторами.
* Текущая load average на сервере - 900, 900, 900
  * что такое, связь с iowait.
* Где в linux хранится информация о процессах?
  * `proc/[PID]` - что за директория, что хранится
* Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?
  1) `mount | grep " $(stat -c%m /home) " | awk '{print $1}'` - определить раздел или volume group
  2) `lsblk` - сопоставить с физическим носителем
  3) `udevadm info --query=all --name=/dev/sda` - получить информацию о носителе
* Как узнать, какими процессами используется раздел? (Указать хотя-бы один)
  1) `lsof 2>/dev/null | grep <source>` - показывает PID, USER, FD, ACCESS, inode, DEVICE (major, minor)
  2) `fuser <source>` - показывает PID
* При создании нового файла система возвращает ошибку no space left device
  * df -i
* df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)
  * Файл занят процессом (файловый дескриптор)
* При создании нового файла пользователем система возвращает ошибку no space left on device
  * inode
  * df -i
  * quota -v user
* В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?
  * file
* Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?
  * Файл не существует
  * Нет исполняемого флага (chmod +x)
  * Несовместимая архитектура
  * Отсутствие интерпретатора для скриптов (bash или Python)
  * Библиотеки, от которых зависит бинарь, отсутствуют
    * ldd - показывает список библиотек
* Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?
  * Объяснить: total, used, free, shared, buff/cache, available
  * used = total - free - buff/cache
  * available = total - used
  * Суть в том, что buff/cache - не важна (чистые страницы)
* Приложение пишет в логи too many opened files, как это диагностировать?
  * /proc/PID/limits - лимиты процесса
  * ulimit -n - лимиты пользователя
  * /etc/systemd/system/<service_name>.service - лимиты сервиса
  * lsof -p PID - сколько открыто файлов
  * strace - глубокий анализ, если процесс не закрывает файлы. (open=close)
* Что такое CPU pinning
  * Привязка определённого ядра (потока) к процессу или группе процессов.
* Как осуществляется обработка сигналов? Чем отличается SIGTERM от SIGKILL?
  * Процесс получает сигнал и выполняет инструкции, описанные в коде
  * SIGSTOP и SIGKILL - обрабатываются всегда, не могут быть проигнорированы.
  * SIGKILL - безусловное завершение; SIGTERM - стандартное завершение.
* Можно ли сделать так, чтобы пользователи могли получать информацию только о своих процессах?
  * hidepid - параметр при монтировании /proc/ 
    * 0 — по умолчанию, все процессы видны (нет скрытия).
    * 1 — пользователи видят только свои процессы, но могут видеть UID и GID процессов других пользователей.
    * 2 — пользователи видят только свои процессы.
* Почему в htop может быть не до конца корректная сводка по потребляемой памяти
  * Рассказать про VIRT, RES, SHR. 
  * Фактическая память это RES-SHR.
* Где в системе можно посмотреть сводку по текущему потреблению памяти?
  * free или top\htop: total, used, free, shared, buff/cache, available.
  * Какие ситуации будут указывать на возможную проблему?
    * Available память или buff/cache близки к нулю или очень маленькое значение.
    * `dmesg` - есть сообщения `out of memory`
* Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?
  * strace
* Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)
  * Скопировать аттрибуты с другого бинарника, а потом скопировать код
    * cp --attributes-only /usr/bin/ls ./new_chmod
    * cat /usr/bin/chmod > ./new_chmod
    * /new_chmod +x /usr/bin/chmod
* База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?
  * тут идёт речь про fsync - подтверждение записи на диск. Процесс ждёт подтверждения
    * Если отключить, то ожидания не будет, но это опасно, зато запись будет быстрой.
* Как ускорить запись на жесткий диск
  * тут идёт речь про fsync - подтверждение записи на диск. Процесс ждёт подтверждения
    * Если отключить, то ожидания не будет, но это опасно, зато запись будет быстрой.
* Что такое разделяемая память?
  * Рассказать про shared memory (mmap)
  * Рассказать про IPC (межпроцессорное взаимодействие)
* Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
  * Вопросы на сообразительность - ответ это просто пример.
  * Суть в том, что есть некоторый глючный процесс и как его отследить
    * Сначала ищем через top
    * Потом через strace c оценкой времени выполнения
      * Выясняем что systemd что-то порождает, оно падает, а systemd ждёт waitid. Всё это в цикле
    * Выясняем через мониторинг systemd (watch ps)
    * Находим файл - источник
    * Удаляем его и ищем что его могло туда поместить.
* допустим у тебя есть бинарник, который запускается и сразу падает, у него все файловые дискрипторы пустые, как бы ты искал решение проблемы?
  * Работа с strace
    * strace ./my_crashing_binary 2>out.txt
    * strace -p 12345 2>out.txt


## Блиц вопросы
1. Что такое Linux и основные компоненты?
   * Linux – это бесплатная операционная система с открытым исходным кодом, основанная на ядре Linux.
    * Перечислить основные компоненты
2. Что такое ядро Linux?
   * Ядро Linux — это основной компонент операционной системы Linux, отвечающий за управление аппаратными ресурсами и предоставление базовых сервисов для всех программ.
   * Системные вызовы (сказать несколько)
   * strace
   * seccomp Capabilities
3. В чем разница между Linux и Unix?
   * Linux — это самостоятельная операционная система, ядро которой было написано Линусом Торвальдсом “с нуля”
   * Linux — не UNIX, но UNIX-подобная система (POSIX-совместимая).
   * UNIX — семейство проприетарных систем
   * Linux заимствует архитектурные идеи UNIX, но код не происходит от исходников UNIX.
4. Что такое inode в Linux? Как найти индекс, связанный с файлом?
   * inode
5. Что такое оболочка Linux? Как проверить текущую оболочку?
   * виды оболочек
   * echo $0
6. Какой командой найти количество памяти и используемую подкачку?
   * free
   * total, used, free, shared, buff/cache, available.
7. Различия между жесткой и символической ссылкой?
   * ln и ln -s
8. Объясните права на файлы в Linux?
   * rwx, 777
   * Специальные биты
   * umask
9. работа с файлами и каталогами?
   * mkdir, touch, cat, mv, cp, rm
13. Как составить список и смонтировать устройства в Linux?
   * df, mount, /etc/fstab
15. Как запланировать задачу в Linux? Что такое crontab и объясните поля в crontab?
   * Cron – это демон, который выполняет команды в определенные даты и время в Linux.
   * crontab -e, -l
   * /etc/cron.daily/
   * `* * * * *` - раскрыть
   * лучше писать абсолютные пути
   * Лучше использовать systemd unit cron
16. Какие основные команды Vim вы знаете?
   * :q!
   * :wq
17. Как добавить двоичный файл в переменную $PATH?
   * $ export PATH=$PATH:/path/to/the/binary/file
18. Объясните команду Grep и регулярные выражения?
19. В чем разница между umask и ulimit?
   * umask - шаблон вычитаемый из прав 666 777
   * ulimit - один из механизмов ограничения ресурсов (действует только в текущем shell)
20. Объясните вывод команды ls в Linux?
   * 1310721 dr-xr-xr-x   2 root root 4.0K Aug 30  2024 cdrom
21. Объясните вывод команды top в Linux?
22. Каковы состояния процесса в Linux?
   * R D S T Z I 
   * < N + s l
23. Как сделать резервную копию или архивировать файлы в Linux (команда tar)?
   * tar -cvf 
   * Нужно ли раскрывать ключи?
24. Как остановить запущенный процесс в Linux?
   * kill
   * сигналы
25. Как искать файлы в linux?
   * find - раскрыть ключи
27. systemctl?
   * systemctl enable
   * рассказать про таргеты юниты и типы сервисов
29. Как выполнить удаленный вход на другой компьютер Linux?
   * Раскрыть про открытые и закрытые ключи в home
   * Возможности sshd сервера: ssh, tftp, проброс портов, ProxyJump(bastion), ограничение команд
30. Как проверить использование диска?
   * df, du
31. Зачем использовать команду export?
   * env
32. Как узнать версию ядра с нескольких серверов Linux, используя скрипт bash?
   * Через for пробежать по списку выполняя ssh root@${server} "uname -r"
   * результат в файл через >>
33. Какие минимальные требования для установки Linux?
   * 25 GB of hard disk space
   * 2 GB RAM
   * 2 Ghz dual core processor
34. Как установить права доступа к файлам / каталогам Linux?
   * chmod, chown
36. Как создать пользователя и группу в Linux?
   * useradd, groupadd
   * adduser, addgroup
37. Как найти версию ядра / ОС в Linux?
   * uname -a
38. Как узнать IP-адрес интерфейса?
   * ip a 
   * ifconfig
39. Что такое образ initrd?
   * инициализация, initramfs
40. Объясните термины suid, sgid и sticky bit?
   * биты из вопроса про права
41. Что такое уровни запуска в linux и как их изменить?
   * Перечислить уровни
   * рассказать про таргеты
   * init N
42. Что такое SeLinux, AppArmor?
   * SELinux — это MAC-система (Mandatory Access Control) в пространстве ядра, основанная на политиках, которые контролируют доступ процессов к файлам, сокетам, портам, IPC и т.д.
43. Что такое dev/null dev/zero?
   * dev/null - черная дыра
   * /dev/zero - постоянные нули (например забить бинарник или образ пустотой)
44. В чем разница между виртуальным хостингом на основе имени и виртуальным хостингом на основе IP?
   * Раскрыть про dns b x

## Вопросы с тех. собеса (linux)






  * Инструменты linux
    * nginx
      * revers-proxy
    * Traefik - почитать, но можно не ставить
    * ps aux -eLf
  * Разработчик написал исходный код и запаковал в архив, есть ссылка и инструкция
    * В инструкции -> только как запустить, но не как собрать из исходиков. 
    * Как скачать: curl, wget
    * Как скомпилить: 
      * gcc
      * make configure
      * make install
    * Чтобы запустить выполните команду с флагами -> вижу выход - она работает. Как запустить демона
      * Скрипт в init.d 
      * cron start
      * unit systemd (targets)
        * type: onshot \ simple \ forking
          * simple - демонизация одного процесса, который не форкается и не завершается
        * sudo systemctl enable start status
        * Процесс выполняется и завершается. В логах просто exited
          * strace - может нет прав?
          * Придумать ещё 2 причины
          * OOMKiller -> dmesg или глянуть рост oom_score
        * Что сделать для запуска?
          * chmod u+x
        * Какую подсистему операционной системы использует утилита (ping)
          * Имеется в виду, что shell форкает процесс и выполняет exec
          * Как утилита получает права на взаимодействие с сетевыми устройствами без sudo
            * Бит запуска с правами владельца (SUID) НЕ ВЕРНО!!!
            * Проверить, как это работает.
          * Вопрос об Capabilities и seccomp
      * Завернуть в контейнер
    * sudoers visudo
    * Как работают админы с пользователями
      * есть основной пользователь (админ)
        * имея доступ к админу создают другую учётку, чтобы случайно не навредить.





* Docker и podman - в чём разница
  * Что такое контейнер по смыслу и задумке
    * Изоляция, повторяемость (унификация), управление ресурсами
      * Механизмы с точки зрения linux
      * Ошибка: ядро в линукс от хостовой системы
      * Что изолируется (рассказать про namespace)
    * Разработка приложения, завтра придёт куча людей и разработчики сделали новые фичи. Дилема: деплоить как процесс или как контейнер.
      * Вопрос про эффективность по ресурсам в контейнере и как процесс. Вопрос по эффективному расходу ресурсов.
        * Вопрос по нагрузке сетевого стека трата ресурсов маршрутизации. NAT, перепаковка трафика. (Проброс хостовой сети)
* kubernetes
  * основные сущности

* Зачем в принципе нужен мониторинг в DevOps (SRE-DevOps)
  * Раскрыть метрики, состояние железа, логи (zabbix, loki)
    * Ситуацияи:
      * Мониторинга нет -> тикет -> ремонт
      * Мониторинг с алертами -> ремонт -> тикет уже не нужны
      * Алерт до катастрофы (реагировать на инцидент до инцидента)
* Человеческий фактор безопасности, какие метрики по итогам проверки.
  * Как оценить, на сколько сотрудники уязвимы к фишингу.
    * Подделка отправителя почтой (не подходящий ответ)
    * Нарушение регламента -> отправить документ на личную почту уволившегося сотрудника или руководителя.
    * Ссылка на ресурс компании (фишинг) -> сколько прошло / сколько ввело пароль

  * iac - определение особенности и преимущества - суть в том, что с инфрой работают как с кодом.
    * Где хранить yaml? -> git -> gitops?
      * Код-ревью
      * История
      * Версионирование
      * Групповые изменения
    * управление состоянием, система сама приводит к нужному состоянию
  * Концепция ci\cd и cd - определение
    * ci - 








1) OS level и компоненты
2) init, текущий init
3) PID
4) Что такое userspace, kernelspace? Чем они отличаются?
2) POSIX
3) SIG kill
3) Что такое системные вызовы?
4) process (статусы;proc/PID/;)
5) Как процессы в системе взаимодействуют между собой?
3) process vs thread
1) 
2) 
2) Что такое процесс? Что такое тред?
8) Какие алгоритмы планирования ресурсов в linux
1) top
2) LA CPU pinning
3) Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности.
2) Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
3) RAM: структура; swap; утилиты; оом киллер
3) Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?
4) Что такое разделяемая память?
3) HDD: WA, блочные/символьные, 
4) Что такое major and minor numbers блочных устройств, чему они соответствуют?
5) Файловые системы, vfs, RAID, lvm, loop devices
6) 
6) inode - что это и где находятся физически.
7) hardlinks vs symlinks; как создать?
7) Где хранится информация об именах файлов, директорий?
6) Как создать файловую систему на блочном устройстве?
7) Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?
7) Каким образом осуществляется монтирование ФС?
8) Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?
2) Как определить, на каком физическом жёстком диске находится раздел с файловой системой?
3) Как узнать, какими процессами используется раздел?
4) При создании нового файла система возвращает ошибку no space left device
5) При создании нового файла пользователем система возвращает ошибку no space left on device
6) Приложение пишет в логи too many opened files.
7) df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)

1) Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли?
2) Как работает система разграничения доступа к файлам в linux? Какие возможности она предоставляет?
3) Основы bash ($,export,stdout,sudo,кавычки); a=5; true | { true && a=10; } чему будет равно a?
4) Файловые дескрипторы.
5) Как узнать что и куда пишет процесс (fd,stdout).
6) Как заставить приложение перестать писать в файл, не завершая процесс?
6) В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?
6) Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?
7) Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?
8) Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)
9) База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?







# Сеть


Статусы сетевого интерфейса.


Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?